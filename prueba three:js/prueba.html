<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Density Practice</title>

			<link rel="stylesheet" type="text/css" href="css/style.css" />
			<script src="build/three.min.js"></script>
			<script src="js/libs/stats.min.js"></script>
			<script src="js/libs/dat.gui.min.js"></script>
	  	<script src="js/controls/OrbitControls.js"></script>
			<script src="js/shaders/OceanShaders.js"></script>
			<script src="js/Ocean.js"></script>
			<script src="js/Mirror.js"></script>
			<script src="js/WaterShader.js"></script>
			<script src="./js/GPUParticleSystem.js" charset="utf-8"></script>

			<script src="assets/VREffect.js"></script>
			<script src="assets/VRControls.js"></script>
			<script src="assets/leap.pinchEvent.js"></script>


			<script type="text/javascript" src="js/Detector.js"></script>
			    <script type="text/javascript" src="js/jquery.min.js"></script>
			  <!--  <script type="text/javascript" src="js/three.min.js"></script>-->
			    <script type="text/javascript" src="js/leap.min.js"></script>
			    <script type="text/javascript" src="LeapCameraControls.js"></script>
			    <script type="text/javascript" src="LeapObjectControls.js"></script>


		<!--	<script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r69/three.min.js"></script>

			-->



	</head>
	<body>

		<div id="topmenu"></div>

		<script>





			// Our Javascript will go here.

			// need scene, camera and renderer

			var scene = new THREE.Scene();

			var width = window.innerWidth
			var height = window.innerHeight

			var huevos = [] , objectsControls = [];
			var lastTime = (new Date()).getTime();
			var gui = new dat.GUI()
			var clock = new THREE.Clock(true)
			var tick = 0;

			var projector, light , cameraControls;

			var menu = document.getElementById( "topmenu" );

			var camera = new THREE.PerspectiveCamera( 75, width/height, 0.1, 1000 );

			var origin = new THREE.Vector3(0, 0, 0);
		        camera.lookAt(origin);
						var renderer;

			// leap camera controls
			cameraControls = new THREE.LeapCameraControls(camera);

			cameraControls.rotateEnabled  = true;
			cameraControls.rotateSpeed    = 3;
			cameraControls.rotateHands    = 1;
			cameraControls.rotateFingers  = [2, 3];

			cameraControls.zoomEnabled    = true;
			cameraControls.zoomSpeed      = 6;
			cameraControls.zoomHands      = 1;
			cameraControls.zoomFingers    = [4, 5];
			cameraControls.zoomMin        = 50;
			cameraControls.zoomMax        = 2000;

			cameraControls.panEnabled     = true;
			cameraControls.panSpeed       = 2;
			cameraControls.panHands       = 2;
			cameraControls.panFingers     = [6, 12];
			cameraControls.panRightHanded = false; // for left-handed person




		  renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );


			projector = new THREE.Projector();

			// camera target coordinate system
			coords1 = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), origin, 75, 0x000000);
			coords2 = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), origin, 75, 0x000000);
			coords3 = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), origin, 75, 0x000000);



			var geometryCyl = new THREE.CylinderGeometry(3, 1.7, 10, 20, 20, true );
			var material =  new THREE.MeshBasicMaterial( {
								color: 0x3794cf,
								wireframe: true,
								//wireframeLinewidth: 10,
								transparent: true,
								opacity: 0.2,
								 } );
			var cylinder = new THREE.Mesh( geometryCyl, material );
			scene.add( cylinder );

			var material = new THREE.MeshBasicMaterial({ color: 0x3794cf });
			var radius = 1.7;
			var segments = 32;
			var circleGeometry = new THREE.CircleGeometry( radius, segments );
			var circle = new THREE.Mesh( circleGeometry, material );
			circle.rotation.x = 4.7
			circle.position.y = -5
			scene.add( circle );


			var sphere = new THREE.Mesh(
 												new THREE.SphereGeometry( 1.6, 32, 32 ),
 												new THREE.MeshBasicMaterial( ) );
 			sphere.position.y = -2.4
 			sphere.position.x = 16

 			//scene.add( sphere );

			var objectControls = new THREE.LeapObjectControls(camera, sphere);

  objectControls.rotateEnabled  = true;
  objectControls.rotateSpeed    = 3;
  objectControls.rotateHands    = 1;
  objectControls.rotateFingers  = [2, 3];

  objectControls.scaleEnabled   = true;
  objectControls.scaleSpeed     = 3;
  objectControls.scaleHands     = 1;
  objectControls.scaleFingers   = [4, 5];

  objectControls.panEnabled     = true;
  objectControls.panSpeed       = 3;
  objectControls.panHands       = 2;
  objectControls.panFingers     = [6, 12];
  objectControls.panRightHanded = false; // for left-handed person

 scene.add(sphere);
  huevos.push(sphere);
  objectsControls.push(objectControls);



			var Water =
			{
				Initialize: function () {
					//this.ms_Camera.position.set(450, 350, 450);

					var gsize = 4;
					var res = 8;
					var gres = res / 2;
					var origx = -gsize / 2;
					var origz = -gsize / 2;
					this.ms_Ocean = new THREE.Ocean(renderer, camera, scene,
					{
						USE_HALF_FLOAT : 'half-float',
						INITIAL_SIZE : 500.0,
						INITIAL_WIND : [10.0, 10.0],
						INITIAL_CHOPPINESS : 4.0,
						CLEAR_COLOR : [1.0, 1.0, 1.0, 0.0],
						GEOMETRY_ORIGIN : [origx, origz],
						SUN_DIRECTION : [1.0, 1.0, 1.0],
						OCEAN_COLOR: new THREE.Vector3(0.03, 0.02, 0.05),
						SKY_COLOR: new THREE.Vector3(3.2, 9.6, 12.8),
						EXPOSURE : 0.4,
						GEOMETRY_RESOLUTION: gres,
						GEOMETRY_SIZE : gsize,
						RESOLUTION : res
					});
					this.ms_Ocean.materialOcean.uniforms.u_projectionMatrix = { type: "m4", value: camera.projectionMatrix };
					this.ms_Ocean.materialOcean.uniforms.u_viewMatrix = { type: "m4", value: camera.matrixWorldInverse };
					this.ms_Ocean.materialOcean.uniforms.u_cameraPosition = { type: "v3", value: camera.position };
					scene.add(this.ms_Ocean.oceanMesh);

				},

				Update: function () {
					var currentTime = new Date().getTime();
					this.ms_Ocean.deltaTime = (currentTime - lastTime) / 1000 || 0.0;
					lastTime = currentTime;
					this.ms_Ocean.render(this.ms_Ocean.deltaTime); //
					this.ms_Ocean.overrideMaterial = this.ms_Ocean.materialOcean;
					if (this.ms_Ocean.changed) {
						this.ms_Ocean.materialOcean.uniforms.u_size.value = this.ms_Ocean.size;
						this.ms_Ocean.materialOcean.uniforms.u_sunDirection.value.set( this.ms_Ocean.sunDirectionX, this.ms_Ocean.sunDirectionY, this.ms_Ocean.sunDirectionZ );
						this.ms_Ocean.materialOcean.uniforms.u_exposure.value = this.ms_Ocean.exposure;
						this.ms_Ocean.changed = false;
					}
					this.ms_Ocean.materialOcean.uniforms.u_normalMap.value = this.ms_Ocean.normalMapFramebuffer ;
					this.ms_Ocean.materialOcean.uniforms.u_displacementMap.value = this.ms_Ocean.displacementMapFramebuffer ;
					this.ms_Ocean.materialOcean.uniforms.u_projectionMatrix.value = camera.projectionMatrix ;
					this.ms_Ocean.materialOcean.uniforms.u_viewMatrix.value = camera.matrixWorldInverse ;
					this.ms_Ocean.materialOcean.uniforms.u_cameraPosition.value = camera.position;
					this.ms_Ocean.materialOcean.depthTest = true;

				},
				// no se usa
				Resize: function (inWidth, inHeight) {
					camera.aspect = inWidth / inHeight;
					camera.updateProjectionMatrix();
					renderer.setSize(inWidth, inHeight);

				}
			};


			var salt = {
				Initialize: function () {
					particleSystem = new THREE.GPUParticleSystem({
				        maxParticles: 3500
				    });

				    particleSystem.position.y = -2

				    scene.add(Â particleSystem);

				    // options passed during each spawned
					options = {
						position: new THREE.Vector3(),
						positionRandomness: 3,
						velocity: new THREE.Vector3(),
						velocityRandomness: 0.0,
						color: 0xffffff,
						colorRandomness: 0.0,
						turbulence: 0.0,
						lifetime: 0.2,
						size: 0,
						sizeRandomness: 0.1
					};

					spawnerOptions = {
						spawnRate: 15,
						horizontalSpeed: 0.0,
						verticalSpeed: 0.0,
						timeScale: 0.1
					}

					gui.add(options, "size", 0, 4);
				},

				Animate: function () {
					var delta = clock.getDelta() * spawnerOptions.timeScale;
				    tick += delta;

				    if (tick < 0) tick = 0;

				    if (delta > 0) {
				    	for (var x = 0; x < spawnerOptions.spawnRate * delta; x++) {
				          	// Yep, that's really it.  Spawning particles is super cheap, and once you spawn them, the rest of
				          	// their lifecycle is handled entirely on the GPU, driven by a time uniform updated below
				          	particleSystem.spawnParticle(options);
				        }
				    }

				    particleSystem.update(tick);
				}
			};


			var btnAddEggs = document.createElement( 'button' );
			btnAddEggs.innerHTML = "Nuevo huevo";
			menu.appendChild( btnAddEggs );
			btnAddEggs.addEventListener( 'click', function() {
																	addEggs();
														 } );

			var btnRemoveEggs = document.createElement( 'button' );
			btnRemoveEggs.innerHTML = "Eliminar huevos";
			menu.appendChild( btnRemoveEggs );
			btnRemoveEggs.addEventListener( 'click', function() {
									                removeEggs();
														 } );



     function addEggs(){
			 var sphere = new THREE.Mesh(
				 									new THREE.SphereGeometry( 1.6, 32, 32 ),
													new THREE.MeshBasicMaterial( ) );
				sphere.position.y = -3.4
				sphere.position.x = 9
				huevos.push( sphere );
				scene.add( sphere );


				//mesh.scale.set(2,2,2)
		 }


     function removeEggs(){
			 for ( var i = 0; i < huevos.length; i ++ ) {
					scene.remove( huevos[i] );
				}
				huevos = [];
		 }

			//var b_ab = document.getElementById( "b_ab" );
			//b_ab.addEventListener( 'click', function() { visualizationType = 2; showAtomsBonds() } );


//in collision
//Water.ms_Ocean.size = 5.0
//				Water.ms_Ocean.changed = true;
//				console.log( Water.ms_Ocean.size )


			controls = new THREE.OrbitControls( camera );
			controls.enableDamping = true;
			controls.dampingFactor = 1;
			controls.enableZoom = true;
			controls.enablePan = false;
			controls.maxDistance = 50.0;
			controls.maxPolarAngle = Math.PI * 0.495;

			camera.position.z = 25;


			var render = function () {
				requestAnimationFrame( render ); //loop

				/*cube.rotation.x += 0.01;
				cube.rotation.y += 0.01;*/

				controls.update();

				Water.Update();
				salt.Animate();

				renderer.render(scene, camera);
			};

			Water.Initialize();
			salt.Initialize();

			render();



		</script>
	</body>
</html>
